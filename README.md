### **1. Как получить ссылку на текущий поток?**
Чтобы получить ссылку на текущий поток, можно использовать статический метод `Thread.currentThread()`:
```java
Thread current = Thread.currentThread();
```
Этот метод возвращает объект текущего потока, выполняющего код.

---

### **2. Зачем нужно ключевое слово synchronized?**
Ключевое слово `synchronized` используется для обеспечения синхронизации потоков при доступе к общим ресурсам. Оно предотвращает состояние гонки, гарантируя, что только один поток может выполнять код, защищённый этим ключевым словом.

**На что можно вешать `synchronized`:**
- **Метод:**
  ```java
  public synchronized void method() {
      // Только один поток может выполнять этот метод одновременно
  }
  ```
  При использовании `synchronized` на нестатическом методе монитор захватывается для текущего объекта (`this`).

- **Статический метод:**
  ```java
  public static synchronized void staticMethod() {
      // Монитор класса
  }
  ```
  При использовании `synchronized` на статическом методе монитор захватывается для класса (`Class`).

- **Блок:**
  ```java
  public void method() {
      synchronized (lock) {
          // Монитор объекта lock
      }
  }
  ```
  Блок позволяет синхронизировать доступ к конкретному объекту.

**Нельзя использовать `synchronized` на полях, классах или конструкторах.**

---

### **3. Захват какого монитора происходит при входе в synchronized метод/статик метод/блок?**

- **Для нестатического метода:** Захватывается монитор текущего объекта (`this`).
- **Для статического метода:** Захватывается монитор объекта класса (`Class`).
- **Для блока:** Захватывается монитор объекта, указанного в скобках:
  ```java
  synchronized (someObject) {
      // Захватывается монитор объекта someObject
  }
  ```

---

### **4. Зачем нужно ключевое слово volatile?**
Ключевое слово `volatile` гарантирует, что изменения переменной одним потоком будут немедленно видны другим потокам. Оно предотвращает кеширование значения переменной в потоках и обеспечивает её чтение из общей памяти.

**На что можно вешать `volatile`:**
- **Только на поля.**
- Нельзя использовать с методами, классами, конструкторами.

Пример:
```java
private volatile boolean running = true;
```

---

### **5. Что делает метод Object#wait, Object#notify, Object#notifyAll?**

Эти методы используются для управления взаимодействием между потоками:

- **`wait()`**:
  - Поток освобождает монитор объекта и переходит в состояние ожидания, пока другой поток не вызовет `notify` или `notifyAll`.
  - Должен вызываться внутри синхронизированного блока.

- **`notify()`**:
  - Пробуждает один из потоков, ожидающих монитор этого объекта.

- **`notifyAll()`**:
  - Пробуждает все потоки, ожидающие монитор этого объекта.

Пример:
```java
synchronized (lock) {
    lock.wait();   // Поток ждёт
    lock.notify(); // Пробуждаем один поток
}
```

---

### **6. Что за исключение IllegalMonitorStateException?**
Исключение `IllegalMonitorStateException` возникает, если вызывается `wait`, `notify`, или `notifyAll` на объекте без захвата его монитора.

Пример:
```java
Object lock = new Object();
lock.wait(); // Ошибка: монитор объекта lock не захвачен
```

Правильный способ:
```java
synchronized (lock) {
    lock.wait(); // Без ошибки
}
```

---

### **7. Что делает метод Thread#join?**
Метод `join()` позволяет текущему потоку ждать завершения другого потока.

Пример:
```java
Thread t = new Thread(() -> {
    System.out.println("Работаю...");
});
t.start();
t.join(); // Текущий поток ждёт завершения потока t
System.out.println("Поток завершён");
```

---

### **8. Что делает метод Thread#interrupt?**
Метод `interrupt()` используется для отправки сигналов прерывания потоку. Он не завершает поток, а только устанавливает флаг прерывания.

Поток может проверить, был ли установлен флаг:
- Через метод `Thread.interrupted()`.
- Если поток находится в состоянии ожидания (`sleep`, `wait`, или `join`), он выбросит исключение `InterruptedException`.

Пример:
```java
Thread t = new Thread(() -> {
    while (!Thread.currentThread().isInterrupted()) {
        System.out.println("Работаю...");
    }
});
t.start();
t.interrupt(); // Прерываем поток
```
